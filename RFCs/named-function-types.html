<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Function types and impl trait - Impl trait initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="../updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="../evaluation.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/apit-and-turbofish.html">APIT and Turbofish</a></li></ol></li><li class="chapter-item "><a href="../explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit.html">Impl trait in argument types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit_turbofish.html">Turbofish</a></li><li class="chapter-item "><a href="../explainer/apit_traits.html">Traits and impls</a></li></ol></li><li class="chapter-item "><a href="../explainer/tait.html">Impl trait in type aliases</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/tait_infer.html">Inferring the hidden type</a></li><li class="chapter-item "><a href="../explainer/tait_ref.html">Referencing from outside the module</a></li><li class="chapter-item "><a href="../explainer/tait_generics.html">Generic parameters</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit.html">Impl trait in return types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/rpit_capture.html">Generic parameter capture</a></li><li class="chapter-item "><a href="../explainer/rpit_names.html">Naming impl trait in return types</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit_trait.html">Return types in trait definitions</a></li><li class="chapter-item "><a href="../explainer/lbit.html">Impl trait in let bindings</a></li><li class="chapter-item "><a href="../explainer/auto_trait.html">Auto traits and impl trait</a></li><li class="chapter-item "><a href="../explainer/inference.html">Appendix A: Inference details</a></li><li class="chapter-item "><a href="../explainer/where_ok.html">Appendix B: Where can impl trait be used</a></li><li class="chapter-item "><a href="../explainer/where_not_ok.html">Appendix C: Where can impl trait NOT be used</a></li><li class="chapter-item "><a href="../explainer/glossary.html">Appendix D: Glossary</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/glossary/defining_scope.html">Defining scope</a></li><li class="chapter-item "><a href="../explainer/glossary/hidden_type.html">Hidden type</a></li><li class="chapter-item "><a href="../explainer/glossary/input_impl_trait.html">Input impl trait</a></li><li class="chapter-item "><a href="../explainer/glossary/output_impl_trait.html">Output impl trait</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../RFC.html">‚ú® RFCs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../RFCs/rpit-in-traits.html">Return position impl Trait in traits</a></li><li class="chapter-item expanded "><a href="../RFCs/named-function-types.html" class="active">Function types and impl trait</a></li></ol></li><li class="chapter-item "><a href="../FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Impl trait initiative</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/impl-trait-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="draft-rfc-named-function-types"><a class="header" href="#draft-rfc-named-function-types">Draft RFC: Named function types</a></h1>
<blockquote>
<p>This is a <strong>draft RFC</strong> that will be submitted to the rust-lang/rfcs repository when it is ready.</p>
<p>Feedback welcome!</p>
</blockquote>
<hr />
<ul>
<li>Feature Name: (fill me in with a unique ident, <code>my_awesome_feature</code>)</li>
<li>Start Date: (fill me in with today's date, YYYY-MM-DD)</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/0000">rust-lang/rfcs#0000</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/0000">rust-lang/rust#0000</a></li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<ul>
<li>Given a function <code>fn foo</code>, introduce a type named <code>fn#foo</code> to represent the zero-sized type of the function (&quot;function def&quot;).
<ul>
<li>When possible, a type named <code>foo</code> is also introduced, unless another type with that name already exists.</li>
</ul>
</li>
<li>The generic parameters of a &quot;function def&quot; type are defined to include only <em>named</em> parameters. Anonymous parameters that appear in the argument are excluded:
<ul>
<li>Elided lifetimes in argument position are excluded.</li>
<li><code>impl Trait</code> in argument position are excluded.</li>
<li>This implies that turbofish with a &quot;function def&quot; type cannot name the <code>impl Trait</code> arguments.</li>
<li>As a temporary measure, &quot;function def&quot; types that have named, late-bound lifetimes cannot accept lifetime parameters.
<ul>
<li>This rule already exists today.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<h2 id="problems-we-are-solving"><a class="header" href="#problems-we-are-solving">Problems we are solving</a></h2>
<p>This RFC proposes two related changes that, together, work to close two remaining major &quot;holes&quot; in the <code>impl Trait</code> story:</p>
<ul>
<li>How to name the return type of a function</li>
<li>How turbofish interacts with <code>impl Trait</code> in argument position (<a href="https://rust-lang.github.io/impl-trait-initiative/explainer/apit.html">explainer</a>)</li>
</ul>
<p>These two problems at first seem orthogonal, but they turn out to be related. Let's first introduce the two problems.</p>
<h3 id="naming-the-return-type-of-a-function"><a class="header" href="#naming-the-return-type-of-a-function">Naming the return type of a function</a></h3>
<p>&quot;Return position&quot; impl Trait (RPIT) generally refers to an <a href="../explaner/rpit.html">&quot;anonymous&quot; opaque type whose value is inferred by the compiler</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn odd_integers(start: u32, stop: u32) -&gt; impl Iterator&lt;Item = u32&gt; {
    (start..stop).filter(|i| i % 2 == 0)
}

// becomes something like:

type OddIntegers = impl Iterator&lt;Item = u32&gt;;
fn odd_integers(start: u32, stop: u32) -&gt; OddIntegers {
    (start..stop).filter(|i| i % 2 == 0)
}
<span class="boring">}
</span></code></pre></pre>
<p>When using <a href="./rpit-in-traits.html">RPIT in traits</a>, this anonymous type is a kind of associated type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIntIterator {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt;;
}

// becomes

trait IntoIntIterator { // desugared
    type IntoIntIter: Iterator&lt;Item = u32&gt;;
    fn into_int_iter(self) -&gt; Self::IntoIntIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>In both cases, it would sometimes be nice to be able to name that return type! Of course, people can introduce type aliases or associated types (similar to the desugared form), but that is inconvenient, and it requires that the API author has made sure to do so.</p>
<h3 id="turbofish-and-impl-trait-in-argument-position"><a class="header" href="#turbofish-and-impl-trait-in-argument-position">Turbofish and impl Trait in argument position</a></h3>
<p><code>impl Trait</code> in argument position <a href="../explainer/apit.html">introduces a new generic parameter to the function</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_to_vec&lt;T&gt;(iter: impl Iterator&lt;Item = T&gt;) -&gt; Vec&lt;T&gt; {
    iter.collect()
}

// is roughly equivalent to:

fn collect_to_vec_desugared&lt;T, I&gt;(iter: I) -&gt; Vec&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt;,
{
    iter.collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>With the desugared version, users can write an expression that manually specifies the values for its type parameters:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = collect_to_vec_desugared::&lt;u32, vec::IntoIter&lt;u32&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>The question addressed here is whether it should be possible to write an equivalent expression for <code>collect_to_vec</code>.</p>
<h2 id="background-material"><a class="header" href="#background-material">Background material</a></h2>
<p>This RFC covers some esoteric corners of Rust's type system. This section provides background material that introduces terms that are necessary to understand what follows.</p>
<h3 id="function-definition-types"><a class="header" href="#function-definition-types">Function definition types</a></h3>
<p>Currently, when you define a function <code>my_function</code>, this declares a value <code>my_function</code> that can be accessed by the user. The type of that value, however, is a bit complicated. Consider this program:</p>
<pre><pre class="playground"><code class="language-rust">fn my_function() {
    println!(&quot;Hello, world&quot;);
}

fn main() {
    let f = my_function;
    println!(&quot;{}&quot;, std::mem::size_of_val(&amp;f));

    let g: fn() = my_function;
    println!(&quot;{}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>Here we reference <code>my_function</code> twice, once to create a variable named <code>f</code> with an inferred type, and once to declare a variable <code>g</code> with type <code>fn()</code>. You might expect that the type of <code>f</code> would be inferred to <code>fn()</code> and that these two variables are equivalent, but if you run this program you will find that their sizes are different: 0 and 8 respectively (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c7904fef1e661bbe82499cfadf7455ae">playground</a>). What is going on?</p>
<p>The answer is that the type of <code>my_function</code> is actually a special zero-sized type called a <em>function definition type</em> (hereafter: fndef). There is a unique fndef type for every function in your program. These types implement the <code>Fn</code> traits, so they can be called: when you call one, the compiler knows <em>exactly</em> what function was called just from the type, since it is tied to a specific function. In contrast, the <code>fn()</code> type represents a function <em>pointer</em> -- it too can be called, but, without some kind of dataflow analysis, the compiler doesn't know what function is being called. This is analogous to using traits with generic types vs <code>dyn Trait</code>.</p>
<p>There is currently no syntax for a fndef type, so there is no way to write the type of <code>f</code> above. The closest you can do is an as-yet-unimplemented extension <code>impl Trait</code>, <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/lbit.html">impl trait in let bindings</a>, which would let you write <code>let f: impl Fn() = my_function</code>.</p>
<h4 id="generic-function-definition-types"><a class="header" href="#generic-function-definition-types">Generic function definition types</a></h4>
<p>The fndef type for a generic function is itself generic. You can specify the values for those generics using turbofish:</p>
<pre><pre class="playground"><code class="language-rust">fn generic_fn&lt;T&gt;(t: T) { }

fn main() {
    let f = generic_fn::&lt;u32&gt;;
}
</code></pre></pre>
<h3 id="early-vs-late-binding"><a class="header" href="#early-vs-late-binding">Early vs late binding</a></h3>
<p>Rust groups generic parameters on functions into two categories: early vs late bound. <em>Early bound</em> parameters are those whose values must be supplied when the function is referenced (either explicitly via turbofish, or implicitly with inference). <em>Late-bound</em> parameters are parameters that are bound only at the time when the function is called. At present, generic type and const parameters are always early bound; lifetime parameters can be either early or late depending on whether they are referenced outside of the argument listing (the exact rules are not pertinent to this RFC).</p>
<p>It is perhaps easiest to understand this by considering the impl of the <code>FnOnce</code> trait for a fndef type. Consider this example, of a function <code>create_with_default</code> that will create an instance of <code>C</code>. The input supplied to the creation function is either the string <code>input</code> or -- in some cases -- a default string.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Create {
    fn create(input: &amp;str);
}

fn create_with_default&lt;'a, C: Create&gt;(input: &amp;'a str) -&gt; C {
    if input.is_empty() {
        C::create(&quot;default&quot;)
    } else {
        C::create(input)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We will refer to the fndef type of <code>create_with_default</code> as <code>create_with_default</code><sup class="footnote-reference"><a href="#surprise">1</a></sup>. Conceptually, there is an impl of <code>FnOnce</code> for <code>create_with_default</code> rather like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, C&gt; FnOnce&lt;(&amp;'a str,)&gt; for create_with_default&lt;C&gt; {
    //             ^^^^^^^^^^                         ^^^
    //                 |                               |
    //                 |            Early bound type parameters
    //                 |            appear in this list.
    //                 |
    // Late bound parameters appear only in these
    // argument types.
    type Output = C;

    fn call(self, args: (&amp;'a str,)) {
        (self)(args.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here there are two &quot;input types&quot; supplied to the trait: the argument parameter <code>A</code> to <code>FnOnce&lt;A&gt;</code>, which defines the types of the arguments being supplied, and the self type (<code>create_with_default&lt;C&gt;</code>), which defines the type of the value being called. The set of generic parameters on the impl is the same as the set on the <code>fn</code> declaration. We can classify those parameters in two ways:</p>
<ul>
<li><strong>Late-bound</strong> parameters are those that appear <strong>only</strong> in the arguments -- this means that they different values can be supplied for them each time the function is called. In this example, the lifetime <code>'a</code> is late-bound.</li>
<li><strong>Early-bound</strong> parameters are those that appear in the <code>Self</code> type. This means that they are &quot;baked into&quot; the function that is being called (which always has a single type) and cannot change from call to call. In this example, <code>C</code> is early-bound.</li>
</ul>
<p>In general, it is better for parameters to be late-bound, as that allows the user more flexibility. However, because of the rules that every impl must be <a href="https://doc.rust-lang.org/nightly/reference/items/implementations.html?highlight=impl#generic-implementations">constrained</a><sup class="footnote-reference"><a href="#why-constrianed">2</a></sup>, parameters that don't appear in the argument types <em>must</em> appear in the Self type, and hence be early bound. In practice, the compiler today only allows lifetimes to be late-bound; all type parameters are early bound. This desugaring however shows that it is possible to consider type parameters as late-bound as well.</p>
<div class="footnote-definition" id="why-constrained"><sup class="footnote-definition-label">3</sup>
<p>...which are there to ensure that the compiler can always figure out what impl to invoke at monomorphization time.</p>
</div>
<div class="footnote-definition" id="surprise"><sup class="footnote-definition-label">1</sup>
<p>Surprise! This is precisely the notation that this RFC is going to propose!</p>
</div>
<h1 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h1>
<p>Please refer to the <a href="https://rust-lang.github.io/impl-trait-initiative/explainer.html">impl trait explainer</a>, which has a section on <a href="https://rust-lang.github.io/impl-trait-initiative/explainer.html">names for return position impl trait</a> that aims to be a &quot;end-user manual&quot; for this feature.</p>
<h1 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h1>
<p>The proposal has a few parts:</p>
<ul>
<li><strong>Named fndef types:</strong> 
<ul>
<li>For every function <code>my_function</code>, define both a value and a type, except when there is already a type with that name.</li>
<li>As a disambiguator, also export a type <code>fn#my_function</code> that can be used to unambiguously name the fndef type.</li>
<li>In traits, for every <code>fn my_function</code> item, introduce a <code>type my_function</code> associated type (except when there is already an associated type with that name).</li>
</ul>
</li>
<li><strong>Late-bound argument position impl Trait:</strong> 
<ul>
<li>Change <code>impl Trait</code> in argument position so that it desugars to &quot;late-bound types&quot;</li>
<li>In so doing, settle the question of whether <code>impl Trait</code> in argument position can be constrained with turbofish (no)</li>
</ul>
</li>
<li><strong>Random bug fixes:</strong>
<ul>
<li>Inherent associated types (<code>impl Foo { type Bar = u32; }</code> and you can write <code>Foo::Bar</code>).</li>
<li>Fix the <code>Foo::Output</code> code in the compiler (not really RFC worthy).</li>
</ul>
</li>
</ul>
<h2 id="named-fndef-types"><a class="header" href="#named-fndef-types">Named fndef types</a></h2>
<p>Introduce a set of changes designed to make it so that users can name the fndef type for every function by writing types whose name is the same as the name that refers to the fn by value:</p>
<ul>
<li><code>foo</code> to name the type for a top-level fn <code>foo</code>.</li>
<li><code>Type::foo</code> to name the type for an inherent method <code>foo</code>.</li>
<li><code>&lt;T as Trait&gt;::foo</code> to name the type for a trait method <code>foo</code> (or <code>Trait::foo</code> and so forth).</li>
</ul>
<h3 id="top-level-function-items"><a class="header" href="#top-level-function-items">Top-level function items</a></h3>
<p>Top-level function declarations like <code>fn my_function</code> will also export a value in the type namespace with the same name (<code>my_function</code>) that corresponds to the fndef type for that function. Therefore, the following works:</p>
<pre><pre class="playground"><code class="language-rust">fn foo() {}

struct SomeType {
    f: foo // refers to the fndef type for `foo`
}

fn main() {
    let x = Sometype { f: foo };
}
</code></pre></pre>
<h3 id="function-definitions-in-traits"><a class="header" href="#function-definitions-in-traits">Function definitions in traits</a></h3>
<p>Function declarations in inherent and trait impls introduce an associated type into the surrounding impl with the same name as the function whose value is the fndef type for the function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Clone {
    // Introduces the equivalent of:
    //
    //     type clone;
    fn clone(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="function-definitions-in-impls"><a class="header" href="#function-definitions-in-impls">Function definitions in impls</a></h3>
<p>Function declarations in inherent and trait impls introduce an associated type into the surrounding impl with the same name as the function whose value is the fndef type for the function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType { }

impl MyType {
    // Introduces:
    //
    //     type new = &lt;fndef for new&gt;;
    fn new() -&gt; Self {

    }
}

impl Clone for MyType {
    // Introduces:
    //
    //     type clone = &lt;fndef for clone&gt;;
    fn clone(&amp;self) -&gt; ... {

    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="shadowing-rules"><a class="header" href="#shadowing-rules">Shadowing rules</a></h3>
<p>Although Rust's naming conventions make this unlikely, it is possible today to define a type and a function with the same name. This obviously presents a conflict in attempting to introduce types with the same names as functions. This section discusses the possible shadowing that can arise in each case and how we manage it. The general strategy is to only generate the fn type if there is not already a type defined with the same name.</p>
<h4 id="edition-rustnext"><a class="header" href="#edition-rustnext">Edition Rust.next</a></h4>
<p>The plan is that in the edition Rust.next (presumably Rust 2024), all cases of shadowing will become hard errors. In the current edition, however, cases of shadowing yield warnings where needed to maintain backwards compatibility.</p>
<h4 id="traits-and-trait-impls"><a class="header" href="#traits-and-trait-impls">Traits and trait impls</a></h4>
<p>If a trait defines an explicit associated type with the same name as one of its functions, then the associated type for that function is suppressed. This also applies to associated types defined in <em>supertraits</em>. Therefore:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo: Bar {

    // A `foo` associated type exists: 
    //
    // nothing is generated for the `fn foo`.
    type foo;
    fn foo(&amp;self);

    // A `bar` associated type exists in the supertrait:
    //
    // nothing is generated for the `fn bar`.
    fn bar(&amp;self);

    // The `Bar` supertrait defines an associated type `baz`, but implicitly:
    //
    // generate an associated type `baz.`
    fn baz(&amp;self);
}

trait Bar {
    type bar;

    fn baz(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p>In all of these cases, we issue warnings. In Rust 2024, this will be an error.</p>
<p><strong>Rationale:</strong> Currently given <code>T: Foo</code>, <code>T::bar</code> would be legal today, so we don't want to generate a type there. But otherwise we do.</p>
<h4 id="inherent-impls"><a class="header" href="#inherent-impls">Inherent impls</a></h4>
<p>Inherent impls do not support associated types today, so we don't have to worry about conflicts.</p>
<p>If an associated type defined on T has the same name as an inherent function on T, then we report an error.</p>
<h4 id="tuple-struct-and-enum-variants"><a class="header" href="#tuple-struct-and-enum-variants">Tuple struct and enum variants</a></h4>
<p>Although not a function declaration, tuple structs and enum variants define constructor functions with the same name as the type itself:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo(u32); // defines a fn `Foo` of type `u32 -&gt; Foo`
<span class="boring">}
</span></code></pre></pre>
<p>In this case, we simply do not generate a fndef type for the constructor. (This is also true in Rust 2024.)</p>
<h4 id="top-level-functions"><a class="header" href="#top-level-functions">Top-level functions</a></h4>
<p>Top-level functions can conflict with named types in a number of ways (examples follow). In all such cases, the intent is to have the function not generate a type alias.</p>
<p><strong>Conflict with prelude</strong> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6719c374699851268dc8ffc363836ffd">playground</a>)</p>
<pre><pre class="playground"><code class="language-rust">fn Vec() {
    
}

fn main() {
    let x = Vec();
}
</code></pre></pre>
<p><strong>Conflict with name from use statement</strong> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=53fc8cd1cea9bd465cbcc4c5dd49f820">playground</a>)</p>
<pre><pre class="playground"><code class="language-rust">mod foo {
    pub type bar = u32;
}

use foo::bar;

fn bar() { }

fn main() {
    
}
</code></pre></pre>
<p><strong>Conflict with macro-generated items</strong> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e3e3cc25cf16bb4cb813854b512b5980">playground</a>)</p>
<pre><pre class="playground"><code class="language-rust">mod foo {
    macro_rules! make_bar {
        () =&gt; { pub type bar = u32; }
    }
    
    make_bar!();
}

use foo::bar;

fn bar() { }

fn main() {
    let x: bar = 22_u32;
}
</code></pre></pre>
<h2 id="late-bound-argument-position-impl-trait-and-turbofish"><a class="header" href="#late-bound-argument-position-impl-trait-and-turbofish">Late-bound argument position impl Trait and turbofish</a></h2>
<p>Currently, impl Trait in argument position is desugared to the equivalent of another explicit parameter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: impl Debug) { }

// becomes roughly equivalent to
// fn foo&lt;D: Debug&gt;(x: D) { }
<span class="boring">}
</span></code></pre></pre>
<p>This parameter is currently considered &quot;early-bound&quot;. As discussed in the motivation, that means that the fndef type <code>foo&lt;D&gt;</code> is generic over some <code>D: Debug</code>. Conceptually it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct foo&lt;D: Debug&gt;;
impl&lt;D: Debug&gt; FnOnce&lt;(D,)&gt; for foo&lt;D&gt; {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This means that if you were to try and name the type of <code>foo</code>, say in a struct, you would need some to way to specify the value of <code>D</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Wrapper {
    f: foo // What is the value of D here?
}
<span class="boring">}
</span></code></pre></pre>
<p>We could allow you to write <code>foo&lt;u32&gt;</code>, but that would be strange, because if you look at the definition of <code>foo</code>, there are no declared type parameters. What's more, if there were multiple <code>impl Trait</code>, we'd have to define an arbitrary ordering for them. Overall, we'd prefer for people to be able to think of <code>impl Trait</code> more intuitively without having to understand the desugaring.</p>
<p>As noted in that section, however, generic parameters that appear in the argument types can be made late-bound instead of early-bound. In the case of <code>impl Trait</code> arguments, they always (by definition) appear in the argument types. Therefore, we could make them &quot;late-bound&quot;, so that they are only parameters of the impl and not of the type. Conceptually then the fndef type for <code>foo</code> would be like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct foo;
impl&lt;D: Debug&gt; FnOnce&lt;(D,)&gt; for foo {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>As a result, the type of <code>foo</code> is just written as <code>foo</code>, with no type arguments, and hence this struct is perfectly legal:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Wrapper {
    f: foo
}
<span class="boring">}
</span></code></pre></pre>
<p>What's more, making <code>impl Trait</code> late bound is actually more flexible. For example, this code does not compile today, but it would under this proposal:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(d: impl Debug) { /* ... */ }

fn main() {
    let f = foo;
    f(22_u32); // call once with `u32`
    f(22_i32); // call again with `i32`
}
</code></pre></pre>
<h3 id="turbofish-interaction"><a class="header" href="#turbofish-interaction">Turbofish interaction</a></h3>
<p>This also settles 'en passante' on of the open questions about impl Trait in argument position: should you be allowed to specify their value in turbofish? Clearly, the answer under this proposal is no, as there are no type parameters whose value needs to be specified.</p>
<h3 id="implication-migration-to-impl-trait-is-not-fully-backwards-compatible"><a class="header" href="#implication-migration-to-impl-trait-is-not-fully-backwards-compatible">Implication: migration to <code>impl Trait</code> is not fully backwards compatible</a></h3>
<p>Settling the turbofish question in this matter does mean that one cannot migrate from a generic function to <code>impl Trait</code> with perfect fidelity:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;D: Debug&gt;(d: D) { }
<span class="boring">}
</span></code></pre></pre>
<p>is different than</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(d: impl Debug) { }
<span class="boring">}
</span></code></pre></pre>
<p>because the former permits turbofish and the latter does not.</p>
<h3 id="implication-backwards-incompatibility-around-inference"><a class="header" href="#implication-backwards-incompatibility-around-inference">Implication: Backwards incompatibility around inference</a></h3>
<p>Unfortunately, there is a <em>slight</em> (largely theoretical) backwards incompatibility with making <code>impl Trait</code> type parameters late bound. It is possible today to leverage inference <em>across</em> calls to the same function. The following code compiles today but would become an error in the future:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(d: impl Debug) { /* ... */ }

fn main() {
    let f = foo;
    f(None); // call with `Option&lt;_&gt;`, unknown value type
    f(Some(22_i32)); // call again with `Option&lt;i32&gt;`
}
</code></pre></pre>
<p>Today, we are able to infer that both calls must be using an <code>Option&lt;i32&gt;</code>. This works because all calls to <code>f</code> must use the same value for the impl trait (it is early bound). If it becomes late bound, that is no longer true, so we would require the <code>f(None)</code> call to use an explicit type annotation (e.g., <code>f(None::&lt;i32&gt;)</code>). <strong>This form of breakage is permitted by our semver rules. We judge the likelihood of this impacting many crates to be small, but we will have to test it.</strong></p>
<h3 id="implication-backwards-incompatibility-around-inference-1"><a class="header" href="#implication-backwards-incompatibility-around-inference-1">Implication: Backwards incompatibility around inference</a></h3>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<h2 id="giving-values-for-uncaptured-parameters"><a class="header" href="#giving-values-for-uncaptured-parameters">Giving values for uncaptured parameters</a></h2>
<p>Impl trait in return position do not capture all </p>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<h2 id="why-not-introduce-the-typeof-keyword"><a class="header" href="#why-not-introduce-the-typeof-keyword">Why not introduce the <code>typeof</code> keyword?</a></h2>
<p>It has been proposed to use the <code>typeof</code> keyword to permit users to take the resulting type from arbitrary expressions. This would mean that one could </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt; { }
<span class="boring">}
</span></code></pre></pre>
<h2 id="why-not-introduce-a-named-type"><a class="header" href="#why-not-introduce-a-named-type">Why not introduce a named type</a></h2>
<h2 id="why-not-introduce-a-named-type-into-the-environment"><a class="header" href="#why-not-introduce-a-named-type-into-the-environment">Why not introduce a named type into the environment?</a></h2>
<p>It is difficult to decide </p>
<h1 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h1>
<p>Discuss prior art, both the good and the bad, in relation to this proposal.
A few examples of what this can include are:</p>
<ul>
<li>For language, library, cargo, tools, and compiler proposals: Does this feature exist in other programming languages and what experience have their community had?</li>
<li>For community proposals: Is this done by some other community and what were their experiences with it?</li>
<li>For other teams: What lessons can we learn from what other communities have done here?</li>
<li>Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.</li>
</ul>
<p>This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture.
If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other languages.</p>
<p>Note that while precedent set by other languages is some motivation, it does not on its own motivate an RFC.
Please also take into consideration that rust sometimes intentionally diverges from common language features.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<ul>
<li>What parts of the design do you expect to resolve through the RFC process before this gets merged?</li>
<li>What parts of the design do you expect to resolve through the implementation of this feature before stabilization?</li>
<li>What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?</li>
</ul>
<h1 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h1>
<p>Think about what the natural extension and evolution of your proposal would
be and how it would affect the language and project as a whole in a holistic
way. Try to use this section as a tool to more fully consider all possible
interactions with the project and language in your proposal.
Also consider how this all fits into the roadmap for the project
and of the relevant sub-team.</p>
<p>This is also a good place to &quot;dump ideas&quot;, if they are out of scope for the
RFC you are writing but otherwise related.</p>
<p>If you have tried and cannot think of any future possibilities,
you may simply state that you cannot think of anything.</p>
<p>Note that having something written down in the future-possibilities section
is not a reason to accept the current or a future RFC; such notes should be
in the section on motivation or rationale in this or subsequent RFCs.
The section merely provides additional information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../RFCs/rpit-in-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../FAQ.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../RFCs/rpit-in-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../FAQ.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
