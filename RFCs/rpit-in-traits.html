<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Return position impl Trait in traits - Impl trait initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="../updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="../evaluation.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/apit-and-turbofish.html">APIT and Turbofish</a></li></ol></li><li class="chapter-item "><a href="../explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit.html">Impl trait in argument types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit_turbofish.html">Turbofish</a></li><li class="chapter-item "><a href="../explainer/apit_traits.html">Traits and impls</a></li></ol></li><li class="chapter-item "><a href="../explainer/tait.html">Impl trait in type aliases</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/tait_infer.html">Inferring the hidden type</a></li><li class="chapter-item "><a href="../explainer/tait_ref.html">Referencing from outside the module</a></li><li class="chapter-item "><a href="../explainer/tait_generics.html">Generic parameters</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit.html">Impl trait in return types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/rpit_capture.html">Generic parameter capture</a></li><li class="chapter-item "><a href="../explainer/rpit_names.html">Naming impl trait in return types</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit_trait.html">Return types in trait definitions</a></li><li class="chapter-item "><a href="../explainer/lbit.html">Impl trait in let bindings</a></li><li class="chapter-item "><a href="../explainer/auto_trait.html">Auto traits and impl trait</a></li><li class="chapter-item "><a href="../explainer/inference.html">Appendix A: Inference details</a></li><li class="chapter-item "><a href="../explainer/where_ok.html">Appendix B: Where can impl trait be used</a></li><li class="chapter-item "><a href="../explainer/where_not_ok.html">Appendix C: Where can impl trait NOT be used</a></li><li class="chapter-item "><a href="../explainer/glossary.html">Appendix D: Glossary</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/glossary/defining_scope.html">Defining scope</a></li><li class="chapter-item "><a href="../explainer/glossary/hidden_type.html">Hidden type</a></li><li class="chapter-item "><a href="../explainer/glossary/input_impl_trait.html">Input impl trait</a></li><li class="chapter-item "><a href="../explainer/glossary/output_impl_trait.html">Output impl trait</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../RFC.html">‚ú® RFCs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../RFCs/rpit-in-traits.html" class="active">Return position impl Trait in traits</a></li><li class="chapter-item "><a href="../RFCs/named-function-types.html">Function types and impl trait</a></li></ol></li><li class="chapter-item "><a href="../FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Impl trait initiative</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/impl-trait-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="return-position-impl-trait-in-traits"><a class="header" href="#return-position-impl-trait-in-traits">Return position impl Trait in traits</a></h1>
<blockquote>
<p>This is a <strong>draft RFC</strong> that will be submitted to the rust-lang/rfcs repository when it is ready.</p>
<p>Feedback welcome!</p>
</blockquote>
<hr />
<h1 id="return-position-impl-trait-in-traits-1"><a class="header" href="#return-position-impl-trait-in-traits-1">Return position impl Trait in traits</a></h1>
<ul>
<li>Feature Name: (fill me in with a unique ident, <code>my_awesome_feature</code>)</li>
<li>Start Date: (fill me in with today's date, YYYY-MM-DD)</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/0000">rust-lang/rfcs#0000</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/0000">rust-lang/rust#0000</a></li>
<li>Developed as part of the <a href="https://github.com/rust-lang/impl-trait-initiative">impl traits lang team initiative</a></li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<ul>
<li>Permit <code>impl Trait</code> in fn return position within traits and trait impls.</li>
<li>This desugars to an anonymous associated type.</li>
</ul>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>The <code>impl Trait</code> syntax is currently accepted in a variety of places within the Rust language to mean &quot;some type that implements <code>Trait</code>&quot; (for an overview, see the <a href="https://rust-lang.github.io/impl-trait-initiative/explainer.html">explainer</a> from the impl trait initiative). For function arguments, <code>impl Trait</code> is <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/apit.html">equivalent to a generic parameter</a> and it is accepted in all kinds of functions (free functions, inherent impls, traits, and trait impls). In return position, <code>impl Trait</code> <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/rpit.html">corresponds to an opaque type whose value is inferred</a>. In that role, it is currently accepted only in free functions and inherent impls. This RFC extends the support to cover traits and trait impls, just like argument position.</p>
<h2 id="example-use-case"><a class="header" href="#example-use-case">Example use case</a></h2>
<p>The use case for <code>-&gt; impl Trait</code> in trait fns is similar to its use in other contexts: traits often wish to return &quot;some type&quot; without specifying the exact type. As a simple example that we will use through the RFC, consider the <code>NewIntoIterator</code> trait, which is a variant of the existing <code>IntoIterator</code> that uses <code>impl Iterator</code> as the return type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait NewIntoIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h1>
<p><em>This section assumes familiarity with the <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/rpit.html">basic semantics of impl trait in return position</a>.</em></p>
<p>When you use <code>impl Trait</code> as the return type for a function within a trait definition or trait impl, the intent is the same: impls that implement this trait return &quot;some type that implements <code>Trait</code>&quot;, and users of the trait can only rely on that. However, the desugaring to achieve that effect looks somewhat different than other cases of impl trait in return position. This is because we cannot desugar to a type alias in the surrounding module; we need to desugar to an associated type (effectively, a type alias in the trait).</p>
<p>Consider the following trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIntIterator {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>The semantics of this are analogous to introducing a new associated type within the surrounding trait;</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIntIterator { // desugared
    type IntoIntIter: Iterator&lt;Item = u32&gt;;
    fn into_int_iter(self) -&gt; Self::IntoIntIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>(In general, this associated type may be generic; it would contain whatever generic parameters are captured per the generic capture rules given previously.)</p>
<p>This associated type is introduced by the compiler and cannot be named by users.</p>
<p>The impl for a trait like <code>IntoIntIterator</code> must also use <code>impl Trait</code> in return position:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIntIterator for Vec&lt;u32&gt; {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; {
        self.into_iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is equivalent to specify the value of the associated type as an <code>impl Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIntIterator for Vec&lt;u32&gt; {
    type IntoIntIter = impl Iterator&lt;Item = u32&gt;
    fn into_int_iter(self) -&gt; Self::IntoIntIter {
        self.into_iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h1>
<h2 id="equivalent-desugaring-for-traits"><a class="header" href="#equivalent-desugaring-for-traits">Equivalent desugaring for traits</a></h2>
<p>Each <code>-&gt; impl Trait</code> notation appearing in a trait fn return type is desugared to an anonymous associated type; the name of this type is a fresh name that cannot be typed by Rust programmers. In this RFC, we will use the name <code>$</code> when illustrating desugarings and the like.</p>
<p>As a simple example, consider the following (more complex examples follow):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait NewIntoIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt;;
}

// becomes

trait NewIntoIterator {
    type Item;

    type $: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; &lt;Self as NewIntoIterator&gt;::$;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="equivalent-desugaring-for-trait-impls"><a class="header" href="#equivalent-desugaring-for-trait-impls">Equivalent desugaring for trait impls</a></h2>
<p>Each <code>-&gt; impl Trait</code> notation appearing in a trait impl fn return type is desugared to the same anonymous associated type <code>$</code> defined in the trait along with a function that returns it. The value of this associated type <code>$</code> is an <code>impl Trait</code>. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;

    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt; {
        self.into_iter()
    }
}

// becomes

impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;
    
    type $ = impl Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; &lt;Self as NewIntoIterator&gt;::$ {
        self.into_iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="impl-trait-must-be-used-in-both-trait-and-trait-impls"><a class="header" href="#impl-trait-must-be-used-in-both-trait-and-trait-impls">Impl trait must be used in both trait and trait impls</a></h2>
<p>Using <code>-&gt; impl Trait</code> notation in a trait requires that all trait impls also use <code>-&gt; impl Trait</code> notation in their return types. Similarly, using <code>-&gt; impl Trait</code> notation in an impl is only legal if the trait also uses that notation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait NewIntoIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt;;
}

// OK:
impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; {
        self.into_iter()
    }
}

// Not OK:
impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;
    fn into_iter(self) -&gt; vec::IntoIter&lt;u32&gt; {
        self.into_iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Rationale:</strong> Maximizing forwards compatibility. We may wish at some point to permit impls and traits to diverge but there is no reason to do it at this time.</p>
<h2 id="generic-parameter-capture-and-gats"><a class="header" href="#generic-parameter-capture-and-gats">Generic parameter capture and GATs</a></h2>
<p>As with <code>-&gt; impl Trait</code> in other kinds of functions, the hidden type for <code>-&gt; impl Trait</code> in a trait may reference any of the type or const parameters declared on the impl or the method; it may also reference any lifetime parameters that explicitly appear in the trait bounds (<a href="https://rust-lang.github.io/impl-trait-initiative/explainer/rpit_capture.html">details</a>). We say that a generic parameter is <em>captured</em> if it may appear in the hidden type.</p>
<p>When desugaring, captured parameters from the method are reflected as generic parameters on the <code>$</code> associated type. Furthermore, the <code>$</code> associated type has the required brings whatever where clauses are declared on the method into scope (excepting those which reference other parameters that are not captured). This transformation is precisely the same as the one which is applied to other forms of <code>-&gt; impl Trait</code>, except that it applies to an associated type and not a top-level type alias.</p>
<p>Exaample:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait RefIterator for Vec&lt;u32&gt; {
    type Item&lt;'me&gt;
    where 
        Self: 'me;

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; impl Iterator&lt;Item = Self:Item&lt;'a&gt;&gt;;
}

// Since 'a is named in the bounds, it is captured.
// `RefIterator` thus becomes:

trait RefIterator for Vec&lt;u32&gt; {
    type Item&lt;'me&gt;
    where 
        Self: 'me;

    type $&lt;'a&gt;: impl Iterator&lt;Item = Self::Item&lt;'a&gt;&gt;
    where 
        Self: 'a; // Implied bound from fn

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::$&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="dyn-safety"><a class="header" href="#dyn-safety">Dyn safety</a></h2>
<p>To start, traits that use <code>-&gt; impl Trait</code> will not be considered dyn safe, <em>even if the method has a <code>where Self: Sized</code> bound</em>. This is because dyn types currently require that all associated types are named, and the <code>$</code> type cannot be named. The other reason is that the value of <code>impl Trait</code> is often a type that is unique to a specific impl, so even if the <code>$</code> type <em>could</em> be named, specifying its value would defeat the purpose of the <code>dyn</code> type, since it would effectively identify the dynamic type.</p>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<h2 id="can-traits-migrate-from-a-named-associated-type-to-impl-trait"><a class="header" href="#can-traits-migrate-from-a-named-associated-type-to-impl-trait">Can traits migrate from a named associated type to <code>impl Trait</code>?</a></h2>
<p>Not compatibly, no, because they would no longer have a named associated type.</p>
<h2 id="can-traits-migrate-from-impl-trait-to-a-named-associated-type"><a class="header" href="#can-traits-migrate-from-impl-trait-to-a-named-associated-type">Can traits migrate from <code>impl Trait</code> to a named associated type?</a></h2>
<p>Generally yes, but all impls would have to be rewritten.</p>
<h2 id="would-there-be-any-way-to-make-it-possible-to-migrate-from-impl-trait-to-a-named-associated-type-compatibly"><a class="header" href="#would-there-be-any-way-to-make-it-possible-to-migrate-from-impl-trait-to-a-named-associated-type-compatibly">Would there be any way to make it possible to migrate from <code>impl Trait</code> to a named associated type compatibly?</a></h2>
<p>Potentially! There have been proposals to allow the values of associated types that appear in function return types to be inferred from the function declaration. So the trait has <code>fn method(&amp;self) -&gt; Self::Iter</code> and the impl has <code>fn method(&amp;self) -&gt; impl Iterator</code>, then the impl would also be inferred to have <code>type Iter = impl Iterator</code> (and the return type rewritten to reference it). This may be a good idea, but it is not proposed as part of this RFC.</p>
<h2 id="what-about-using-a-named-associated-type"><a class="header" href="#what-about-using-a-named-associated-type">What about using a named associated type?</a></h2>
<p>One alternative under consideration was to use a named associated type instead of the anonymous <code>$</code> type. The name could be derived by converting &quot;snake case&quot; methods to &quot;camel case&quot;, for example. This has the advantage that users of the trait can refer to the return type by name.</p>
<p>We decided against this proposal:</p>
<ul>
<li>Introducing a name by converting to camel-case feels surprising and inelegant.</li>
<li>Return position impl Trait in other kinds of functions doesn't introduce any sort of name for the return type, so it is not analogous.</li>
</ul>
<p>There is a need to introduce a mechanism for naming the return type for functions that use <code>-&gt; impl Trait</code>; we plan to introduce a second RFC addressing this need uniformly across all kinds of functions.</p>
<p>As a backwards compatibility note, named associated types could likely be introduced later, although there is always the possibility of users having introduced associated types with the same name.</p>
<h2 id="does-auto-trait-leakage-still-occur-for---impl-trait-in-traits"><a class="header" href="#does-auto-trait-leakage-still-occur-for---impl-trait-in-traits">Does auto trait leakage still occur for <code>-&gt; impl Trait</code> in traits?</a></h2>
<p>Yes, so long as the compiler has enough type information to figure out which impl you are using. In other words, given a trait function <code>SomeTrait::foo</code>, if you invoke a function <code>&lt;T as SomeTrait&gt;::foo()</code> where the self type is some generic parameter <code>T</code>, then the compiler doesn't really know what impl is being used, so no auto trait leakage can occur. But if you were to invoke <code>&lt;u32 as SomeTrait&gt;::foo()</code>, then the compiler could resolve to a specific impl, and hence a specific <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html">impl trait type alias</a>, and auto trait leakage would occur as normal.</p>
<h2 id="would-introducing-a-named-associated-type-be-a-breaking-change-for-a-trait"><a class="header" href="#would-introducing-a-named-associated-type-be-a-breaking-change-for-a-trait">Would introducing a named associated type be a breaking change for a trait?</a></h2>
<p>Converting from returning impl trait to an explicit associated type is a breaking change for impls of the trait. Given this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn bar() -&gt; impl Display;
}

impl Foo for u32 {
    fn bar() -&gt; impl Display {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>transforming it to the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar: Display;
    fn bar() -&gt; Self::Bar;
}

impl Foo for u32 {
    fn bar() -&gt; impl Display {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Results in an impl in the <code>impl Foo for u32</code>. The <a href="#future-possibilities">Future possibilities section</a> discusses some possible ways we could mitigate this in the future by other language extensions.</p>
<h1 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h1>
<p>There are a number of crates that do desugaring like this manually or with procedural macros. One notable example is <a href="https://crates.io/crates/real-async-trait">real-async-trait</a>.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<ul>
<li>None.</li>
</ul>
<h1 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h1>
<p>We expect to introduce a mechanism for naming the result of <code>-&gt; impl Trait</code> return types in a follow-up RFC (see the draft <a href="https://rust-lang.github.io/impl-trait-initiative/RFCs/named-function-types.html">named function types</a> rfc for the current thinking).</p>
<p>Similarly, we expect to be introducing language extensions to address the inability to use <code>-&gt; impl Trait</code> types with dynamic dispatch. These mechanisms are needed for async fn as well. A good writeup of the challenges can be found on the &quot;challenges&quot; page of the <a href="https://rust-lang.github.io/async-fundamentals-initiative/evaluation/challenges/dyn_traits.html">async fundamentals initiative</a>.</p>
<p>Finally, it would be possible to introduce a mechanism that allows users to give a name to the associated type that is returned by impl trait. One proposed mechanim is to support an inference mechanism, so that one if you have a function <code>fn foo() -&gt; Self::Foo</code> that returns an associated type, the impl only needs to implement the function, and the compiler infers the value of <code>Foo</code> from the return type. Another options would be to extend the impl trait syntax generally to let uses give a name to the type alias or parameter that is introduced.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../RFC.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../RFCs/named-function-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../RFC.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../RFCs/named-function-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
